\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{xcolor}

\title{CI de Rust}
\author{SANNA Thomas, L3STI}
\date{\today}

\lstset{
  ,
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  tabsize=4,
  captionpos=b
}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Nom du langage}
Rust

\section{Créateur}
Graydon Hoare

\section{Première apparition}
2010

\section{Paradigmes}
\begin{itemize}
    \item Impératif (pas purement impératif)
    \item Fonctionnel
\end{itemize}

\section{Typage}
\begin{itemize}
    \item Statique
    \item Fort
    \item Inféré
\end{itemize}

\section{Peut-on créer de nouveau type ?}
Oui
\begin{lstlisting}[]
struct Point {
    x: f64,
    y: f64,
}
\end{lstlisting}

\section{Différents types}
\begin{itemize}
    \item i32, i64, u32, u64, f32, f64 (= int32bits, int64bits, unsigned int32bits, unsigned int64bits, float32bits, float64bits)
    \item bool
    \item char
\end{itemize}

\section{Gestion de la mémoire}
\begin{itemize}
    \item Pas de garbage collector
    \item Propriété et emprunt (ownership and borrowing)
    \item Allocation manuelle et automatique
\end{itemize}

\section{Sécurité}
\begin{itemize}
    \item Sécurité mémoire garantie par le compilateur
    \item Vérification des emprunts à la compilation
    \item Absence de data races
\end{itemize}

\section{Interopérabilité}
\begin{itemize}
    \item Interopérabilité avec C et C++
    \item FFI (Foreign Function Interface)
\end{itemize}

\section{Utilisations courantes}
\begin{itemize}
    \item Développement système
    \item Applications embarquées
    \item WebAssembly
    \item Services web
    \item Jeux vidéo
\end{itemize}

\section{Niveau d'abstraction}
Élevé

\section{Popularité}
En forte croissance

\section{Mutabilité}
\begin{itemize}
    \item Rust est un langage immuable par défaut
    \item Mutabilité explicite
\end{itemize}

\section{Syntaxe}
\subsection{Print "Hello, world!"}
\begin{lstlisting}[]
fn main() {
    println!("Hello, world!");
}
\end{lstlisting}

\subsection{Fonctions}
\begin{lstlisting}[]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let a = 5;
    let b = 10;
    let c = add(a, b);
    println!("{} + {} = {}", a, b, c);
}
\end{lstlisting}

\subsection{Structures}
\begin{lstlisting}[]
struct Point {
    x: f64,
    y: f64,
}

impl Point {
    fn new(x: f64, y: f64) -> Self {
        Self { x, y }
    }

    fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let point = Point::new(3.0, 4.0);
    println!("Distance de l'origine : {}", point.distance_from_origin());
}
\end{lstlisting}

\subsection{Enumérations}
\begin{lstlisting}[]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}

fn move_player(d: Direction) {
    match d {
        Direction::Up => println!("Le joueur monte"),
        Direction::Down => println!("Le joueur descend"),
        Direction::Left => println!("Le joueur va à gauche"),
        Direction::Right => println!("Le joueur va à droite"),
    }
}

fn main() {
    move_player(Direction::Up);
}
\end{lstlisting}

\subsection{Traits}
\begin{lstlisting}[]
trait Animal {
    fn make_sound(&self);
}

struct Chien;

impl Animal for Chien {
    fn make_sound(&self) {
        println!("Ouaf");
    }
}

struct Chat;

impl Animal for Chat {
    fn make_sound(&self) {
        println!("Miaou");
    }
}

fn main() {
    let chien = Chien;
    let chat = Chat;

    chien.make_sound();
    chat.make_sound();
}
\end{lstlisting}

\subsection{Gestion des erreurs}
\begin{lstlisting}[]
fn division(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("Division par zéro".to_string())
    } else {
        Ok(a / b)
    }
}

fn main() {
    match division(9.0, 3.0) {
        Ok(result) => println!("Résultat : {}", result),
        Err(err) => println!("Erreur : {}", err),
    }
}
\end{lstlisting}

\subsection{Itérateurs}
\begin{lstlisting}[]
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    for number in numbers.iter() {
        println!("{}", number);
    }
}
\end{lstlisting}

\subsection{Pattern matching}
\begin{lstlisting}[]
fn main() {
    let number = 42;

    match number {
        0 => println!("Zéro"),
        1..=100 => println!("Entre 1 et 100"),
        _ => println!("Autre"),
    }
}
\end{lstlisting}

\subsection{Gestion de la mémoire}
\begin{lstlisting}[]
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}", s1); // Erreur : s1 a été déplacé
}

// avec type simple :
fn main() {
    let x = 5;
    let y = x;

    println!("{}", x); // Ok car i32 est copié
}
\end{lstlisting}

\subsection{Booleens}
\begin{lstlisting}[]
fn main() {
    let a = true;
    let b = false;

    if a && b {
        println!("a et b sont vrais");
    } else if a || b {
        println!("a ou b est vrai");
    } else {
        println!("a et b sont faux");
    }
}
\end{lstlisting}

\end{document}